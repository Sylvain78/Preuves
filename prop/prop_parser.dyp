{
 open Formula_prop
 let parser = ref None;;
 let string_without_quote s = ( String.sub s 1 (String.length s - 2))

(*keep all interpretations*)
 let dyp_merge_Obj_expr l = match l with
   | (_,gd,ld)::_ -> List.map (fun (o,_,_) -> o) l, gd, ld
      | [] -> assert false

}

%start expr1
%layout [' ' '\t' '\n']

%lexer

let lowercase = ['a'-'z']
let uppercase = ['A'-'Z']
let digit = ['0'-'9']
let ident = (lowercase|uppercase)(lowercase|uppercase|digit)*
let any_string = '"' (['\000'-'\033'] | ['\035'-'\255'])* '"'

%parser
/*
Load the parser at beginning of parsing*/
expr1 : 
    | ...@{(),match !parser with | None -> [] | Some pdev -> [Dyp.Parser pdev] } expr eof { $2 }


expr:
    | "X_" ['0'-'9']+  { PVar (PVVar (int_of_string $2)) }
    | "X_{" ['0'-'9']+ "}" { PVar (PVVar (int_of_string $2)) }
    | "\\mathbb{" ['a'-'z''A'-'Z'] "}" { PVar (PVMetaVar ($2)) }
    | "(" expr ")" { $2 }
    | "\\lnot" expr { PNeg($2) }
    | expr "\\implies" expr { PImpl($1,$3) }
    | expr "\\land" expr { PAnd($1,$3) }
    | expr "\\lor" expr { POr($1,$3) }

/*SKE Example of notation
"
Notation
equiv
Param
a b
Syntax
a "\equiv" b 
Semantics
(a \imply b)/\\(b \imply a)
End
"
*/

%%

{
  let formula_from_string s = 
    let l = (expr1 (Dyp.from_string (pp ()) s))
    in 
    match l with [ (f,_) ] -> f 
               | (f,_)::(g,_)::_ -> raise (Failure ("[Prop] Parser.formula_from_string("^ s ^") : more than one interpretation"))
	       |   _   -> raise (Failure ("[Prop] Parser.formula_from_string("^ s ^")"))

} 
%mli {
val formula_from_string : string -> Formula_prop.formula_prop 
}
