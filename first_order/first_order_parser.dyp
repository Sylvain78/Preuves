%mltop {
 open Signature
 open Formula
 module Parser (S:SIGNATURE) = struct
 module G = Formula(S)

}

%start <G.formula> main
%layout [' ' '\t' '\n']

%parser
main: formula eof { let module G = Formula(S) in ($1 : G.formula) }


term:
	| "X_" ['0'-'9']+  { let module G = Formula(S) in G.V(G.Var (int_of_string $2)) }
/*	| "X_{" ['0'-'9']+ "}" { V(Var  (int_of_string $2)) }*/
/*	| "(" term ")" { ($2 : term) }*/

formula: 
	| term "=" term { let module G = Formula(S) in G.Atomic_formula(G.Eq($1,$3)) }
	| "\\forall X_" ['0'-'9']+ formula { let module G = Formula(S) in G.Forall(G.Var(int_of_string $2), $3)}
	| "\\exists X_" ['0'-'9']+ formula { let module G = Formula(S) in G.Exists(G.Var(int_of_string $2), $3)}

%%
{
let formula_from_string s = 
	print_string s;flush stdout;
   let l = (main (Dyp.from_string (pp ()) s))
   in 
   match l with [ (f,s) ] -> f 
              |   _   -> raise (Failure "[First_order] Parser.formula_from_string")

end
}

%mlitop {
open Signature
open Formula
module Parser : functor (S:SIGNATURE) -> sig
module G : module type of Formula(S)
}

%mli {
val formula_from_string : string -> G.formula
end 
}
